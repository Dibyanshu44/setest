
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Campus Navigator</title>
    <style>
        body {
            font-family: 'sans-serif';
            background-color: #f3f4f6;
            color: #1f2937;
            margin: 0;
            padding: 0;
        }
        
        header {
            background-color: #ffffff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 1rem 0;
        }
        
        header .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }
        
        h1 {
            font-size: 1.875rem;
            font-weight: 700;
            color: #1f2937;
            margin: 0;
        }
        
        main .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
        }
        
        .controls-container {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 1rem;
            background-color: #fff;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
        }
        
        .controls-container > div {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        
        .controls-container label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #4b5563;
            margin-bottom: 0.25rem;
        }
        
        .controls-container select {
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 1rem;
            background-color: #f9fafb;
        }
        
        .controls-container button {
            padding: 0.75rem 1.5rem;
            background-color: #4f46e5;
            color: #fff;
            font-weight: 600;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        
        .controls-container button:hover {
            background-color: #4338ca;
        }
        
        .navigation-controls {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            background-color: #fff;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
            align-items: center;
            text-align: center;
        }
        
        #current-instruction-box {
            background-color: #dbeafe;
            color: #1e40af;
            padding: 0.75rem;
            border-radius: 8px;
            font-weight: 600;
        }
        
        #message-box {
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 500;
            width: 100%;
            text-align: center;
        }
        
        .hidden {
            display: none !important;
        }
        
        .error {
            background-color: #fecaca;
            color: #991b1b;
        }
        
        .success {
            background-color: #d1fae5;
            color: #065f46;
        }
        
        .info {
            background-color: #dbeafe;
            color: #1e40af;
        }
        
        canvas {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
            max-width: 100%;
            height: auto;
            border: 1px solid #d1d5db;
        }
        
        .legend {
            background-color: #fff;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
        }
        
        .legend h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        
        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .legend-items > div {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-items p {
            margin: 0;
            font-size: 0.875rem;
        }
        
        .legend-color-path, .legend-color-room, .legend-color-corridor, .legend-color-girls-toilet, .legend-color-boys-toilet, .legend-color-stairs-lift, .legend-color-entrance-exit, .legend-color-tracker {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
        }
        
        .legend-color-path { background-color: #ef4444; }
        .legend-color-room { background-color: #d1fae5; }
        .legend-color-corridor { background-color: #fde68a; }
        .legend-color-girls-toilet { background-color: #fecaca; }
        .legend-color-boys-toilet { background-color: #dbeafe; }
        .legend-color-stairs-lift { background-color: #e9d5ff; }
        .legend-color-entrance-exit { background-color: #fca5a5; }
        .legend-color-tracker { background-color: #2563eb; }
        
        footer {
            text-align: center;
            padding: 1rem;
            font-size: 0.875rem;
            color: #6b7280;
            background-color: #e5e7eb;
            margin-top: auto;
        }
        
        /* Responsive Styles */
        @media (min-width: 768px) {
            main .container {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-start;
                gap: 2rem;
            }
            
            .controls-container, .navigation-controls, .legend {
                width: 300px;
            }
        
            .controls-container > div {
                width: auto;
            }
        
            .controls-container button {
                width: 100%;
                margin-top: 1rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Campus Navigator</h1>
        </div>
    </header>

    <main>
        <div class="container">
            <div class="controls-container">
                <div>
                    <label for="start-room">Current Location</label>
                    <select id="start-room">
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <div>
                    <label for="end-room">Destination</label>
                    <select id="end-room">
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <div>
                    <button id="find-path-btn">
                        Find Path
                    </button>
                </div>
            </div>
            
            <div id="message-box" class="info"></div>
            
            <div class="navigation-controls hidden" id="navigation-controls">
                <div id="current-instruction-box">
                    <p id="current-instruction">Select a path to begin navigation.</p>
                </div>
            </div>

            <canvas id="map-canvas"></canvas>

            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-items">
                    <div>
                        <div class="legend-color-path"></div>
                        <p>Path</p>
                    </div>
                    <div>
                        <div class="legend-color-room"></div>
                        <p>Room</p>
                    </div>
                    <div>
                        <div class="legend-color-corridor"></div>
                        <p>Corridor</p>
                    </div>
                    <div>
                        <div class="legend-color-girls-toilet"></div>
                        <p>Toilet (Girls)</p>
                    </div>
                    <div>
                        <div class="legend-color-boys-toilet"></div>
                        <p>Toilet (Boys)</p>
                    </div>
                    <div>
                        <div class="legend-color-stairs-lift"></div>
                        <p>Stairs/Lift</p>
                    </div>
                    <div>
                        <div class="legend-color-entrance-exit"></div>
                        <p>Entrance/Exit</p>
                    </div>
                    <div>
                        <div class="legend-color-tracker"></div>
                        <p>Your Position</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <p>&copy; 2024 Campus Navigator. All rights reserved.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('map-canvas');
            const ctx = canvas.getContext('2d');
            const findPathBtn = document.getElementById('find-path-btn');
            const startRoomSelect = document.getElementById('start-room');
            const endRoomSelect = document.getElementById('end-room');
            const messageBox = document.getElementById('message-box');
            const navigationControls = document.getElementById('navigation-controls');
            const currentInstruction = document.getElementById('current-instruction');
            const gridSize = 25;
            const gridWidth = 35;
            const gridHeight = 25;
            const headingTolerance = 25; // Degrees of tolerance for a turn
        
            let gridLayout;
            let nodes;
            let roomCoordinates = {};
            let currentPath = [];
            let playerPosition = { x: -1, y: -1, name: '' };
            let playerPathIndex = 0;
            let playerHeading = 0; // The heading from the DeviceOrientation API
        
            const typeColors = {
                "empty": "#ffffff",
                "corridor": "#fde68a",
                "room": "#d1fae5",
                "girls_toilet": "#fecaca",
                "boys_toilet": "#dbeafe",
                "stair": "#e9d5ff",
                "lift": "#e9d5ff",
                "B-entrance": "#fca5a5",
                "A-entrance": "#fca5a5",
            };
        
            async function init() {
                try {
                    const response = await fetch("stitched.json");
                    const jsonData = await response.json();
                    
                    gridLayout = jsonData.layout.Floor_0;
                    nodes = jsonData.nodes;
        
                    canvas.width = gridWidth * gridSize;
                    canvas.height = gridHeight * gridSize;
                    
                    precomputeRoomCoordinates();
                    populateDropdowns();
                    drawGrid();
        
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                            .then(permissionState => {
                                if (permissionState === 'granted') {
                                    window.addEventListener('deviceorientation', handleOrientation);
                                } else {
                                    showMessage("Permission for device orientation was denied. Compass will not work.", "error");
                                }
                            })
                            .catch(console.error);
                    } else {
                        window.addEventListener('deviceorientation', handleOrientation);
                    }
        
                } catch (error) {
                    console.error('Error loading map data:', error);
                    showMessage('Failed to load map data. Please ensure "stitched.json" is in the same directory.', "error");
                }
            }
        
            function handleOrientation(event) {
                // event.alpha is the direction relative to North (0-360)
                playerHeading = 360 - event.alpha;
                updateNavigation();
            }

            function precomputeRoomCoordinates() {
                roomCoordinates = {};
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const cell = gridLayout[y] && gridLayout[y][x];
                        if (cell && cell.name) {
                            roomCoordinates[cell.name] = { x, y };
                        }
                    }
                }
            }
        
            function getCellColor(cell) {
                if (cell.type in typeColors) {
                    return typeColors[cell.type];
                }
                const namePrefix = cell.name?.charAt(0);
                if (namePrefix === 'c') return typeColors['corridor'];
                if (namePrefix === 's' || namePrefix === 'l') return typeColors['stair'];
                if (cell.name in typeColors) return typeColors[cell.name];
                return '#d1fae5';
            }
        
            function findNearestAmenity(startRoom, amenityType) {
                let shortestPath = null;
                let nearestAmenity = null;
                
                for (const roomName in nodes) {
                    if (nodes[roomName].type === amenityType) {
                        const path = bfs(startRoom, roomName);
                        if (path && (shortestPath === null || path.length < shortestPath.length)) {
                            shortestPath = path;
                            nearestAmenity = roomName;
                        }
                    }
                }
                return nearestAmenity;
            }
        
            function populateDropdowns() {
                const roomList = [];
                startRoomSelect.innerHTML = '';
                endRoomSelect.innerHTML = '';
        
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Select a location';
                startRoomSelect.appendChild(emptyOption.cloneNode(true));
                endRoomSelect.appendChild(emptyOption.cloneNode(true));
                
                const girlsToiletOption = document.createElement('option');
                girlsToiletOption.value = 'girls_toilet';
                girlsToiletOption.textContent = 'Nearest Girls\' Toilet';
                endRoomSelect.appendChild(girlsToiletOption);
        
                const boysToiletOption = document.createElement('option');
                boysToiletOption.value = 'boys_toilet';
                boysToiletOption.textContent = 'Nearest Boys\' Toilet';
                endRoomSelect.appendChild(boysToiletOption);
        
                const liftOption = document.createElement('option');
                liftOption.value = 'lift';
                liftOption.textContent = 'Nearest Lift';
                endRoomSelect.appendChild(liftOption);
        
                const stairOption = document.createElement('option');
                stairOption.value = 'stair';
                stairOption.textContent = 'Nearest Staircase';
                endRoomSelect.appendChild(stairOption);
        
                for (const roomName in nodes) {
                    const roomNode = nodes[roomName];
                    const isAmenity = roomNode.type === 'girls_toilet' || roomNode.type === 'boys_toilet' || roomNode.type === 'lift' || roomNode.type === 'stair';
                    const isCorridor = roomNode.type === 'corridor';
                    if (!isAmenity && !isCorridor) {
                        roomList.push(roomName);
                    }
                }
                
                roomList.sort().forEach(room => {
                    const startOption = document.createElement('option');
                    startOption.value = room;
                    startOption.textContent = room;
                    startRoomSelect.appendChild(startOption);
        
                    const endOption = document.createElement('option');
                    endOption.value = room;
                    endOption.textContent = room;
                    endRoomSelect.appendChild(endOption);
                });
            }
        
            function drawGrid() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
        
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const cell = gridLayout[y] && gridLayout[y][x] ? gridLayout[y][x] : { type: 'empty' };
                        const color = getCellColor(cell);
                        ctx.fillStyle = color;
                        ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                        
                        ctx.strokeStyle = '#d1d5db';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
        
                        if (cell.type === 'girls_toilet') {
                            ctx.fillStyle = '#1f2937';
                            ctx.font = '9px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText("Girls", x * gridSize + gridSize / 2, y * gridSize + gridSize / 2 - 5);
                            ctx.fillText("Toilet", x * gridSize + gridSize / 2, y * gridSize + gridSize / 2 + 5);
                        } else if (cell.type === 'boys_toilet') {
                            ctx.fillStyle = '#1f2937';
                            ctx.font = '9px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText("Boys", x * gridSize + gridSize / 2, y * gridSize + gridSize / 2 - 5);
                            ctx.fillText("Toilet", x * gridSize + gridSize / 2, y * gridSize + gridSize / 2 + 5);
                        } else if (cell.type === 'lift') {
                            ctx.fillStyle = '#1f2937';
                            ctx.font = '9px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText("Lift", x * gridSize + gridSize / 2, y * gridSize + gridSize / 2);
                        } else if (cell.type === 'stair') {
                            ctx.fillStyle = '#1f2937';
                            ctx.font = '9px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText("Stair", x * gridSize + gridSize / 2, y * gridSize + gridSize / 2);
                        } else if (cell.name && cell.type !== 'corridor') {
                            ctx.fillStyle = '#1f2937';
                            ctx.font = '9px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(cell.name, x * gridSize + gridSize / 2, y * gridSize + gridSize / 2);
                        }
                    }
                }
            }
        
            function drawTracker(x, y, heading) {
                const centerX = x * gridSize + gridSize / 2;
                const centerY = y * gridSize + gridSize / 2;
                const arrowSize = 8;
                
                ctx.fillStyle = '#2563eb';
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(heading * Math.PI / 180);
        
                ctx.beginPath();
                ctx.moveTo(0, -arrowSize);
                ctx.lineTo(-arrowSize, arrowSize);
                ctx.lineTo(arrowSize, arrowSize);
                ctx.closePath();
                ctx.fill();
        
                ctx.restore();
            }
        
            function findPathCoordinates(path) {
                const coordinates = [];
                for (const roomName of path) {
                    const coord = roomCoordinates[roomName];
                    if (coord && coord.x < gridWidth && coord.y < gridHeight) {
                        coordinates.push({
                            x: coord.x * gridSize + gridSize / 2,
                            y: coord.y * gridSize + gridSize / 2
                        });
                    }
                }
                return coordinates;
            }
        
            function drawPath(pathCoordinates) {
                if (pathCoordinates.length < 2) return;
        
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.beginPath();
                
                ctx.moveTo(pathCoordinates[0].x, pathCoordinates[0].y);
        
                for (let i = 1; i < pathCoordinates.length; i++) {
                    ctx.lineTo(pathCoordinates[i].x, pathCoordinates[i].y);
                }
                ctx.stroke();
        
                ctx.fillStyle = '#ef4444';
                pathCoordinates.forEach(coord => {
                    ctx.beginPath();
                    ctx.arc(coord.x, coord.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        
            function bfs(start, end) {
                const queue = [[start]];
                const visited = new Set();
                
                while (queue.length > 0) {
                    const currentPath = queue.shift();
                    const currentNode = currentPath[currentPath.length - 1];
        
                    if (currentNode === end) {
                        return currentPath;
                    }
        
                    if (!visited.has(currentNode)) {
                        visited.add(currentNode);
                        const neighbors = nodes[currentNode]?.neighbors || [];
                        for (const neighbor of neighbors) {
                            const neighborType = nodes[neighbor]?.type;
                            
                            if ((neighborType !== 'lift' && neighborType !== 'stair') || neighbor === end) {
                                if (!visited.has(neighbor)) {
                                    const newPath = [...currentPath, neighbor];
                                    queue.push(newPath);
                                }
                            }
                        }
                    }
                }
                return null;
            }
        
            function getRequiredHeading(fromNode, toNode) {
                const fromCoord = roomCoordinates[fromNode];
                const toCoord = roomCoordinates[toNode];
        
                if (!fromCoord || !toCoord) return null;
        
                const dx = toCoord.x - fromCoord.x;
                const dy = toCoord.y - fromCoord.y;
        
                return Math.atan2(dx, -dy) * 180 / Math.PI;
            }

            function getNextDirectionInstruction(path, playerIndex, currentHeading) {
                if (playerIndex >= path.length - 1) {
                    return "You have arrived at your destination!";
                }
                const nextNodeName = path[playerIndex + 1];
                const playerNodeName = path[playerIndex];
                
                const neededHeading = getRequiredHeading(playerNodeName, nextNodeName);
                if (neededHeading === null) return "Lost track of path.";
        
                const deltaAngle = (neededHeading - currentHeading + 360) % 360;
                
                // Check if the current heading is close to the needed heading
                const isStraight = (Math.abs(deltaAngle) <= headingTolerance || Math.abs(deltaAngle - 360) <= headingTolerance);
                const isLeftTurn = (deltaAngle > 180 && deltaAngle < 360 - headingTolerance);
                const isRightTurn = (deltaAngle > headingTolerance && deltaAngle < 180);
                const isTurnAround = (Math.abs(deltaAngle - 180) <= headingTolerance);

                if (isStraight) {
                    return `Go straight towards ${nextNodeName}.`;
                } else if (isLeftTurn) {
                    return `Turn left towards ${nextNodeName}.`;
                } else if (isRightTurn) {
                    return `Turn right towards ${nextNodeName}.`;
                } else if (isTurnAround) {
                    return `Turn around and go towards ${nextNodeName}.`;
                }
        
                return `Proceed to ${nextNodeName}.`;
            }
        
            function showMessage(message, type = 'info') {
                messageBox.textContent = message;
                messageBox.classList.remove('hidden', 'error', 'success', 'info');
                messageBox.classList.add(type);
            }
        
            function redrawMap() {
                drawGrid();
                if (currentPath.length > 0) {
                    const pathCoords = findPathCoordinates(currentPath);
                    drawPath(pathCoords);
                    const playerNode = currentPath[playerPathIndex];
                    if (roomCoordinates[playerNode]) {
                        const nextNode = currentPath[playerPathIndex + 1];
                        let heading = getRequiredHeading(playerNode, nextNode) || 0;
                        drawTracker(roomCoordinates[playerNode].x, roomCoordinates[playerNode].y, heading);
                    }
                }
            }
        
            function updateNavigation() {
                if (currentPath.length > 0 && playerPathIndex < currentPath.length - 1) {
                    const playerNodeName = currentPath[playerPathIndex];
                    const nextNodeName = currentPath[playerPathIndex + 1];
                    const neededHeading = getRequiredHeading(playerNodeName, nextNodeName);
        
                    if (neededHeading !== null) {
                        const delta = Math.abs(neededHeading - playerHeading);
                        // Check if player is facing the right direction to advance
                        if (delta < headingTolerance || delta > 360 - headingTolerance) {
                            playerPathIndex++;
                            // Check if destination is reached
                            if (playerPathIndex >= currentPath.length - 1) {
                                currentInstruction.textContent = "You have arrived at your destination!";
                                showMessage("You have arrived!", "success");
                                navigationControls.classList.add('hidden');
                            } else {
                                const nextInstruction = getNextDirectionInstruction(currentPath, playerPathIndex, playerHeading);
                                currentInstruction.textContent = nextInstruction;
                                showMessage(`Following path...`, "info");
                            }
                        }
                    }
                }
                redrawMap();
            }
        
            findPathBtn.addEventListener('click', () => {
                const startRoom = startRoomSelect.value;
                const endRoom = endRoomSelect.value;
        
                if (!startRoom || !endRoom) {
                    showMessage("Please select both a start and end location.", "error");
                    navigationControls.classList.add('hidden');
                    return;
                }
        
                if (startRoom === endRoom) {
                    showMessage("Start and end locations are the same. No path to show.", "info");
                    navigationControls.classList.add('hidden');
                    return;
                }
        
                let actualEndRoom = endRoom;
                if (['girls_toilet', 'boys_toilet', 'lift', 'stair'].includes(endRoom)) {
                    const nearestAmenity = findNearestAmenity(startRoom, endRoom);
                    if (nearestAmenity) {
                        actualEndRoom = nearestAmenity;
                    } else {
                        showMessage(`No ${endRoom.replace('_', ' ')}s found.`, "error");
                        navigationControls.classList.add('hidden');
                        return;
                    }
                }
        
                currentPath = bfs(startRoom, actualEndRoom);
        
                if (currentPath) {
                    const startCoord = roomCoordinates[startRoom];
                    playerPosition = { x: startCoord.x, y: startCoord.y, name: startRoom };
                    playerPathIndex = 0;
                    
                    redrawMap();
                    const firstInstruction = getNextDirectionInstruction(currentPath, playerPathIndex, playerHeading);
                    currentInstruction.textContent = firstInstruction;
                    
                    showMessage(`Path found from ${startRoom} to ${actualEndRoom}!`, "success");
                    navigationControls.classList.remove('hidden');
        
                } else {
                    showMessage("No path could be found between the selected locations.", "error");
                    navigationControls.classList.add('hidden');
                }
            });
        
            init();
        });
    </script>
</body>
</html>
